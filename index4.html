<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>DKP Web App (Browser only)</title>

  <!-- SheetJS for Excel/CSV read & write -->
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
  <!-- localForage (IndexedDB wrapper) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/localforage/1.10.0/localforage.min.js"></script>

  <style>
    :root {
      --bg: #f6f8fa;
      --card: #ffffff;
      --accent: #0b74d1;
      --muted: #586069;
      --table-wrap: #fff;
    }
    *{box-sizing:border-box}
    
    body {
      margin:0;
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      background: var(--bg);
      color: #111827;
    }
    tr, td {
      border: 2px solid;
    }
    .container { 
      max-width:1100px; 
      margin:24px auto; 
      padding:16px; 
    }
    
    header h1 { 
      margin:0 0 6px; 
    }
    
    .muted { 
      color: var(--muted); 
      font-size:0.9rem; 
    }
    
    .card {
      background: var(--card);
      padding:14px;
      padding-top:5px;
      border-radius:10px;
      box-shadow: 0 4px 18px rgba(11,20,40,0.04);
      margin:14px 0;
    }
    
    .row {
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      margin-top:10px;
    }
    
    input[type="file"] { 
      padding:6px; 
    }
    
    input[type="number"], input[type="text"], input[type="search"], 
    input#vacation-input, input#pr-min, input#pr-max, input#pr-percent {
      padding:8px 10px; 
      border-radius:6px; 
      border:1px solid #e2e8f0; 
      min-width:120px;
    }

    button {
      padding:8px 12px; 
      border-radius:8px; 
      border: none; 
      cursor:pointer; 
      background:#e6eef9; 
      color:#053b6b;
    }

    ::file-selector-button {
      padding:4px 6px; 
      border-radius:8px; 
      border: none; 
      cursor:pointer; 
      background:#e6eef9; 
      color:#053b6b;
    }
    
    table { 
      width:100%; 
      border-collapse:collapse; 
      margin-top:8px; 
    }
    
    thead th { 
      text-align:left; 
      padding:8px; 
      font-weight:600; 
      border-bottom: 1px solid #eef2f7; 
    }
    
    tbody td { 
      padding:8px; 
      border-bottom:1px solid #f3f6fb; 
    }
    
    small { 
      color:var(--muted) 
    }
    
    #results-table-wrap { 
      overflow:auto; 
      max-height:420px; 
      border-radius:8px; 
      background: var(--table-wrap); 
      padding:8px; 
    }
    
    progress { 
      width:200px; 
      height:14px; 
    }
    
    .file-col { 
      min-width:240px; 
    }
    
    footer { 
      margin-top:18px; 
    }
    
    /* --- Dark mode --- */
    body.dark {
      background: #111;
      color: #f1f1f1;
      --muted: white;
      --table-wrap: #ddd;
    }
    
    body.dark .card {
      background: #1a1a1a;
      box-shadow: 0 4px 12px rgba(0,0,0,0.6);
    }
    
    body.dark table {
      background: #1e1e1e;
      color: #ddd;
    }
    
    body.dark thead th {
      border-bottom: 1px solid #333;
    }
    
    body.dark tbody td {
      border-bottom: 1px solid #222;
    }
    
    body.dark input, body.dark select {
      background: #222;
      color: #eee;
      border: 1px solid #444;
    }
    
    body.dark button {
      background: #333;
      color: #eee;
    }

    body.dark ::file-selector-button {
      background: #333;
      color: #eee;
    }

    body.dark #results-table-wrap {
      background: #1a1a1a;
    }
    
    /* --- Scrollbar styling for Results table --- */

    /* Light mode scrollbars */
    #results-table-wrap::-webkit-scrollbar {
      height: 10px;
      width: 10px;
    }
    
    #results-table-wrap::-webkit-scrollbar-track {
      background: #e6e6e6;
      border-radius: 8px;
    }
    
    #results-table-wrap::-webkit-scrollbar-thumb {
      background-color: #a0a0a0;
      border-radius: 8px;
      border: 2px solid #e6e6e6;
    }
    
    #results-table-wrap::-webkit-scrollbar-thumb:hover {
      background-color: #7a7a7a;
    }
    
    /* Firefox */
    #results-table-wrap {
      scrollbar-width: thin;
      scrollbar-color: #a0a0a0 #e6e6e6;
    }
    
    /* --- Dark mode scrollbars --- */
    body.dark #results-table-wrap::-webkit-scrollbar-track {
      background: #1b1b1b;
    }
    
    body.dark #results-table-wrap::-webkit-scrollbar-thumb {
      background-color: #444;
      border: 2px solid #1b1b1b;
    }
    
    body.dark #results-table-wrap::-webkit-scrollbar-thumb:hover {
      background-color: #666;
    }
    
    body.dark #results-table-wrap {
      scrollbar-color: #555 #1b1b1b;
    }
    
    /* --- Scrollbar styling for Power Ranges table --- */
    #power-ranges-wrap {
      overflow: auto;
      max-height: 70vh; /* optional: ensures table scrolls if long */
    }
    
    /* Light mode scrollbars */
    #power-ranges-wrap::-webkit-scrollbar {
      height: 10px;
      width: 10px;
    }
    
    #power-ranges-wrap::-webkit-scrollbar-track {
      background: #e6e6e6;
      border-radius: 8px;
    }
    
    #power-ranges-wrap::-webkit-scrollbar-thumb {
      background-color: #a0a0a0;
      border-radius: 8px;
      border: 2px solid #e6e6e6;
    }
    
    #power-ranges-wrap::-webkit-scrollbar-thumb:hover {
      background-color: #7a7a7a;
    }
    
    /* Firefox */
    #power-ranges-wrap {
      scrollbar-width: thin;
      scrollbar-color: #a0a0a0 #e6e6e6;
    }
    
    /* --- Dark mode scrollbars --- */
    body.dark #power-ranges-wrap::-webkit-scrollbar-track {
      background: #1b1b1b;
    }
    
    body.dark #power-ranges-wrap::-webkit-scrollbar-thumb {
      background-color: #444;
      border: 2px solid #1b1b1b;
    }
    
    body.dark #power-ranges-wrap::-webkit-scrollbar-thumb:hover {
      background-color: #666;
    }
    
    body.dark #power-ranges-wrap {
      scrollbar-color: #555 #1b1b1b;
    }

  </style> 
  
</head>
<body>
  <div class="container">
    <header>
      <h1>DKP Calculator â€” Browser-only</h1>
      <p class="muted">No backend. Data persisted locally (IndexedDB).</p>
    </header>

    <!-- SETTINGS (top) -->
    <section class="card">
      <h2>Settings</h2>
      <div class="row">
        <button id="theme-toggle">ðŸŒ™ Dark mode</button>
        <button id="export-settings">ðŸ’¾ Export Settings (.json)</button>
        <button id="import-settings">ðŸ“‚ Import Settings (.json)</button>
        <input id="import-settings-file" type="file" accept=".json" style="display:none" />
        <button id="clear-min-dkp">ðŸ§¹ Clear all saved Min DKP</button>
        <div class="muted" style="margin-left:10px;">Export/import includes multipliers, power ranges, vacation list and min_dkp.</div>
      </div>
    </section>

    <main>
      <section class="card">
        <h2>Multipliers</h2>
        <div class="row">
          <label>T4: <input id="t4" type="number" step="0.01"></label>
          <label>T5: <input id="t5" type="number" step="0.01"></label>
          <label>Deads: <input id="deads" type="number" step="0.01"></label>
          <button id="save-multipliers">Save</button>
        </div>
      </section>

      <section class="card">
        <h2>Power Ranges (Min â†’ Max optional â†’ %)</h2>
        <div id="power-ranges-wrap">
          <table id="power-ranges-table">
            <thead><tr><th>Min</th><th>Max</th><th>%</th><th>Actions</th></tr></thead>
            <tbody></tbody>
          </table>
          <div class="row">
            <input id="pr-min" placeholder="Min power (integer)">
            <input id="pr-max" placeholder="Max power (optional)">
            <input id="pr-percent" placeholder="Percentage (e.g. 0.6)">
            <button id="pr-add">Add / Update</button>
            <button id="pr-save">Save ranges</button>
          </div>
        </div>
      </section>

      <section class="card">
        <h2>Vacation List</h2>
        <div class="row">
          <input id="vacation-input" placeholder="IDs, comma separated (e.g. 123,456)">
          <button id="vac-save">Save Vacation List</button>
          <button id="vac-clear">Clear Vacation List</button>
        </div>
      </section>

      <section class="card">
        <h2>Input Scans</h2>
        <div class="row">
          <div class="file-col">
            <label>First scan (old): <input id="file1" type="file" accept=".xlsx,.xls,.csv"></label>
            <small>Header names supported: ID, Name, Power, Killpoints, Deads, T4 Kills, T5 Kills, CH</small>
          </div>
          <div class="file-col">
            <label>Latest scan (new): <input id="file2" type="file" accept=".xlsx,.xls,.csv"></label>
          </div>
        </div>

        <div class="row">
          <label>DKP Mode:
            <label><input name="mode" value="lilithdata" type="radio" checked> Lilith</label>
            <label><input name="mode" value="default" type="radio"> Default</label>
          </label>
        </div>

        <div class="row">
          <button id="run-dkp" class="primary">Calculate DKP</button>
          <progress id="progress" max="100" value="0"></progress>
        </div>

        <div class="row">
          <button id="export-xlsx">Export XLSX</button>
          <button id="export-csv">Export CSV</button>
          <button id="export-json">Export JSON</button>
        </div>
      </section>

      <section class="card">
        <h2>Results (Top rows)</h2>
        <div id="results-info" class="muted">No results yet.</div>
        <div id="results-table-wrap"></div>
      </section>

      <footer class="muted">
        <small>Data persisted locally with IndexedDB (localForage). Min DKP values are saved and reused across runs.</small>
      </footer>
    </main>
  </div>

  <script>
    /* DKP Browser-only implementation (updated)
       - Uses XLSX (SheetJS) to read/write files client-side
       - Uses localForage (IndexedDB) for persistence
       - New: Settings export/import and clear-all-min-dkp
       - New: Skip IDs where CH < 25 (CH header expected - normalized)
    */
    
    (() => {
      // -------------------------
      // Setup localforage store
      // -------------------------
      localforage.config({ name: "dkp_web_app" });
    
      // Keys
      const KEY_MULT = "multipliers";
      const KEY_PR = "power_ranges";
      const KEY_VAC = "vacation_list";
      const KEY_MIN = "min_dkp";
    
      // UI elements
      const t4El = document.getElementById("t4");
      const t5El = document.getElementById("t5");
      const deadsEl = document.getElementById("deads");
      const saveMultBtn = document.getElementById("save-multipliers");
    
      const prTableBody = document.querySelector("#power-ranges-table tbody");
      const prMin = document.getElementById("pr-min");
      const prMax = document.getElementById("pr-max");
      const prPercent = document.getElementById("pr-percent");
      const prAddBtn = document.getElementById("pr-add");
      const prSaveBtn = document.getElementById("pr-save");
    
      const vacInput = document.getElementById("vacation-input");
      const vacSaveBtn = document.getElementById("vac-save");
      const vacClearBtn = document.getElementById("vac-clear");
    
      const file1El = document.getElementById("file1");
      const file2El = document.getElementById("file2");
      const runBtn = document.getElementById("run-dkp");
      const progressEl = document.getElementById("progress");
      const resultsWrap = document.getElementById("results-table-wrap");
      const resultsInfo = document.getElementById("results-info");
    
      const exportX = document.getElementById("export-xlsx");
      const exportC = document.getElementById("export-csv");
      const exportJ = document.getElementById("export-json");
    
      const exportSettingsBtn = document.getElementById("export-settings");
      const importSettingsBtn = document.getElementById("import-settings");
      const importSettingsFile = document.getElementById("import-settings-file");
      const clearMinBtn = document.getElementById("clear-min-dkp");
    
      // In-memory caches
      let powerRanges = []; // [{min_power, max_power|null, percentage}]
      let multipliers = { t4: 0.0, t5: 0.0, deads: 0.0 };
      let vacationList = []; // array of ids (strings)
      let minDkpMap = {}; // id -> min_dkp (number)
      let lastResults = null; // array of result objects
    
      // -------------------------
      // Helpers: persistence
      // -------------------------
      async function loadAllFromStorage() {
        const m = await localforage.getItem(KEY_MULT);
        if (m) multipliers = m;
        const pr = await localforage.getItem(KEY_PR);
        if (Array.isArray(pr)) powerRanges = pr.slice();
        const v = await localforage.getItem(KEY_VAC);
        if (Array.isArray(v)) vacationList = v.slice();
        const md = await localforage.getItem(KEY_MIN);
        if (md && typeof md === "object") minDkpMap = md;
      }
    
      async function saveMultipliers() {
        multipliers = { t4: parseFloat(t4El.value) || 0, t5: parseFloat(t5El.value) || 0, deads: parseFloat(deadsEl.value) || 0 };
        await localforage.setItem(KEY_MULT, multipliers);
        alert("Multipliers saved locally.");
      }
    
      async function savePowerRangesToStorage() {
        powerRanges.sort((a, b) => a.min_power - b.min_power);
        await localforage.setItem(KEY_PR, powerRanges);
        alert("Power ranges saved locally.");
      }
    
      async function saveVacationList() {
        const raw = vacInput.value.trim();
        if (!raw) {
          vacationList = [];
        } else {
          vacationList = raw.split(",").map(s => s.trim()).filter(Boolean);
        }
        await localforage.setItem(KEY_VAC, vacationList);
        alert("Vacation list saved.");
      }
    
      async function clearVacationList() {
        if (!confirm("Clear vacation list (set to empty)?")) return;
        vacationList = [];
        vacInput.value = "";
        await localforage.setItem(KEY_VAC, vacationList);
        alert("Vacation list cleared.");
      }
    
      async function saveMinDkpMap() {
        await localforage.setItem(KEY_MIN, minDkpMap);
      }
    
      async function clearAllMinDkp() {
        if (!confirm("Are you sure? This will remove all stored Min DKP values.")) return;
        await localforage.removeItem(KEY_MIN);
        minDkpMap = {};
        alert("All Min DKP values cleared.");
      }
    
      // -------------------------
      // UI: power ranges table
      // -------------------------
      function renderPowerRanges() {
        prTableBody.innerHTML = "";
        powerRanges.forEach((r, idx) => {
          const tr = document.createElement("tr");
          tr.innerHTML = `<td>${r.min_power}</td><td>${r.max_power === null ? "" : r.max_power}</td><td>${r.percentage}</td>
            <td>
              <button class="pr-edit" data-idx="${idx}">Edit</button>
              <button class="pr-delete" data-idx="${idx}">Delete</button>
            </td>`;
          prTableBody.appendChild(tr);
        });
        prTableBody.querySelectorAll(".pr-edit").forEach(btn => {
          btn.addEventListener("click", (e) => {
            const i = Number(e.currentTarget.dataset.idx);
            const r = powerRanges[i];
            prMin.value = r.min_power;
            prMax.value = r.max_power === null ? "" : r.max_power;
            prPercent.value = r.percentage;
            prAddBtn.dataset.editIdx = i;
            prAddBtn.textContent = "Update";
          });
        });
        prTableBody.querySelectorAll(".pr-delete").forEach(btn => {
          btn.addEventListener("click", async (e) => {
            const i = Number(e.currentTarget.dataset.idx);
            if (!confirm("Delete this range?")) return;
            powerRanges.splice(i, 1);
            await savePowerRangesToStorage();
            renderPowerRanges();
          });
        });
      }
    
      prAddBtn.addEventListener("click", async () => {
        const minv = parseInt(prMin.value, 10);
        if (Number.isNaN(minv)) return alert("Min power must be an integer");
        const maxRaw = prMax.value.trim();
        const maxv = maxRaw === "" ? null : (Number.isInteger(Number(maxRaw)) ? parseInt(maxRaw, 10) : null);
        const perc = parseFloat(prPercent.value);
        if (Number.isNaN(perc)) return alert("Percentage required (e.g. 0.6)");
    
        const item = { min_power: minv, max_power: maxv, percentage: perc };
    
        if (prAddBtn.dataset.editIdx !== undefined) {
          const idx = Number(prAddBtn.dataset.editIdx);
          powerRanges[idx] = item;
          delete prAddBtn.dataset.editIdx;
          prAddBtn.textContent = "Add / Update";
        } else {
          powerRanges.push(item);
        }
        await savePowerRangesToStorage();
        renderPowerRanges();
        prMin.value = prMax.value = prPercent.value = "";
      });
    
      prSaveBtn.addEventListener("click", async () => {
        await savePowerRangesToStorage();
        renderPowerRanges();
      });
    
      // -------------------------
      // Utility: read spreadsheet file (.xlsx or .csv)
      // -------------------------
      async function readSpreadsheetFile(file) {
        if (!file) throw new Error("No file provided");
        const arrBuf = await file.arrayBuffer();
        const wb = XLSX.read(arrBuf, { type: "array" });
        const first = wb.SheetNames[0];
        const sheet = wb.Sheets[first];
        const json = XLSX.utils.sheet_to_json(sheet, { defval: null });
        // Normalize header keys: lowercase & trimmed & mapping to expected columns
        return json.map(row => {
          const normalized = {};
          Object.keys(row).forEach(k => {
            const key = String(k).trim().toLowerCase();
            const val = row[k];
            if (["character id", "id"].includes(key)) normalized.ID = val;
            else if (["username", "name"].includes(key)) normalized.Name = val;
            else if (["current power", "power"].includes(key)) normalized.Power = val;
            else if (["total kill points", "killpoints", "kills"].includes(key)) normalized.Killpoints = val;
            else if (["deaths", "deads"].includes(key)) normalized.Deads = val;
            else if (["t4", "t4 kills", "tier 4 kills"].includes(key)) normalized["T4 Kills"] = val;
            else if (["t5", "t5 kills", "tier 5 kills"].includes(key)) normalized["T5 Kills"] = val;
            else if (["ch", "city hall", "cityhall", "city hall level"].includes(key)) normalized.CH = val;
            else normalized[k] = val; // keep other columns if any
          });
          return normalized;
        });
      }
    
      // -------------------------
      // DKP logic port (JS version)
      // -------------------------
      function getMinDkpPercent(power) {
        for (const r of powerRanges) {
          if (r.max_power === null) {
            if (power >= r.min_power) return Number(r.percentage);
          } else {
            if (power >= r.min_power && power < r.max_power) return Number(r.percentage);
          }
        }
        return 0.6;
      }
    
      function safeNum(v) {
        const n = Number(v);
        return Number.isFinite(n) ? n : 0;
      }
    
      // return CH numeric or null
      function getChFromRow(row) {
        if (!row || row.CH === undefined || row.CH === null || String(row.CH).trim() === "") return null;
        const n = Number(row.CH);
        return Number.isFinite(n) ? n : null;
      }
    
      async function calculateDkp({ mode = "lilithdata" } = {}) {
        const f1 = file1El.files[0];
        const f2 = file2El.files[0];
        if (!f1 || !f2) return alert("Please select both files.");
        progressEl.value = 5;
    
        const [df1Raw, df2Raw] = await Promise.all([readSpreadsheetFile(f1), readSpreadsheetFile(f2)]);
        progressEl.value = 20;
    
        const mapById = (arr) => {
          const m = {};
          arr.forEach(r => {
            const idS = String(r.ID ?? "").trim();
            if (!idS) return;
            m[idS] = r;
          });
          return m;
        };
    
        const map1 = mapById(df1Raw);
        const map2 = mapById(df2Raw);
    
        progressEl.value = 35;
    
        // build list of all unique IDs
        const allIdsSet = new Set([...Object.keys(map1), ...Object.keys(map2)]);
        const allIds = Array.from(allIdsSet);
    
        // Filter IDs based on CH: skip if CH < 25 in both files (or missing in both)
        const filteredIds = allIds.filter(id => {
          const ch1 = getChFromRow(map1[id]);
          const ch2 = getChFromRow(map2[id]);
          // If either CH is >= 25 -> include
          if ((ch1 !== null && ch1 >= 25) || (ch2 !== null && ch2 >= 25)) return true;
          // otherwise skip
          return false;
        });
    
        const skippedCount = allIds.length - filteredIds.length;
        if (skippedCount > 0) {
          console.info(`Skipped ${skippedCount} IDs due to CH < 25 (or missing).`);
        }
    
        // Ensure min_dkp exists for filtered IDs
        await ensureMinDkpForIds(filteredIds, df1Raw, df2Raw, map1, map2);
        progressEl.value = 55;
    
        const results = [];
        const t4 = multipliers.t4, t5 = multipliers.t5, deads = multipliers.deads;
    
        for (const id of filteredIds) {
          const a = map1[id] || {};
          const b = map2[id] || {};
          const name = (b.Name ?? a.Name ?? "Missing") + "";
          const powerVal = safeNum(b.Power ?? a.Power ?? 0);
          let t4g = 0, t5g = 0, deg = 0, kp = 0;
          if (mode === "default") {
            t4g = safeNum(b["T4 Kills"]) - safeNum(a["T4 Kills"]);
            t5g = safeNum(b["T5 Kills"]) - safeNum(a["T5 Kills"]);
            deg = safeNum(b.Deads) - safeNum(a.Deads);
            kp = safeNum(b.Killpoints) - safeNum(a.Killpoints);
          } else {
            t4g = safeNum(b["T4 Kills"]);
            t5g = safeNum(b["T5 Kills"]);
            deg = safeNum(b.Deads);
            kp = safeNum(b.Killpoints);
          }
    
          const minDkp = minDkpMap[id] !== undefined ? Number(minDkpMap[id]) : Math.round(powerVal * getMinDkpPercent(powerVal));
          const DKP = Math.round((t4g * t4) + (t5g * t5) + (deg * deads));
          const DKPpercent = minDkp ? (DKP / minDkp) : 0;
    
          const status = (a.Power === undefined || a.Power === null || a.Power === "") ? "missing in start" :
                         (b.Power === undefined || b.Power === null || b.Power === "") ? "missing in new" : "OK";
    
          const vacation = vacationList.includes(id) ? "YES" : "NO";
                
            // Build the row object
            const row = {
            ID: id,
            Name: name,
            Power: powerVal,
            
            "KP gained": Math.round(kp),
            "T4 gained": Math.round(t4g),
            "T5 gained": Math.round(t5g),
            "Deads gained": Math.round(deg),

            "Min DKP": Math.round(minDkp),
            "DKP": Math.round(DKP),
            "DKP%": Number.isFinite(DKPpercent) ? Number(DKPpercent.toFixed(4)) : 0,
            "Vacation": vacation,
            "Status": status,
            
            // Full totals
            "T4 Kills": safeNum(a["T4 Kills"]),
            "T5 Kills": safeNum(a["T5 Kills"]),
            "Killpoints": safeNum(a.Killpoints),
            "Deads": safeNum(a.Deads),
  
            "Power diff": Math.round((safeNum(b.Power) - safeNum(a.Power)))
            };
            
            // ðŸ”¹ Zero out all stats if user is missing in either scan
            if (status === "missing in start" || status === "missing in new") {
              Object.keys(row).forEach(k => {
                if (!["ID", "Name", "Power", "Status", "Vacation"].includes(k)) {
                  row[k] = 0;
                }
              });
            }
            
            results.push(row);
        }
    
        results.sort((x, y) => y.DKP - x.DKP);
    
        lastResults = results;
        renderResultsTable(results);
        progressEl.value = 100;
        resultsInfo.textContent = `Calculated ${results.length} rows (skipped ${skippedCount} due to CH<25).`;
      }
    
      // Ensure min_dkp exists only for filtered IDs
      async function ensureMinDkpForIds(allIds, df1, df2, map1, map2) {
        const toInsert = [];
        for (const gid of allIds) {
          const gidStr = String(gid).trim();
          if (gidStr === "") continue;
          if (minDkpMap[gidStr] !== undefined) continue;
          // find power in df1 then df2
          const findPower = (arr, map) => {
            const row = (map && map[gidStr]) || arr.find(r => String(r.ID).trim() === gidStr && r.Power != null && r.Power !== "");
            if (!row) return null;
            const p = Number(row.Power);
            return Number.isFinite(p) ? p : null;
          };
          let power = findPower(df1, map1);
          if (power === null) power = findPower(df2, map2);
          if (power === null) {
            console.warn(`[DKP] No Power for ID ${gidStr} â€” skipping min_dkp calculation`);
            continue;
          }
          const perc = getMinDkpPercent(power);
          const minDkp = Math.round(power * perc);
          minDkpMap[gidStr] = minDkp;
          toInsert.push({ id: gidStr, minDkp });
        }
        if (toInsert.length) await saveMinDkpMap();
      }
    
      // -------------------------
      // Render results (table)
      // -------------------------
      function renderResultsTable(rows) {
        resultsWrap.innerHTML = "";
        if (!rows || rows.length === 0) {
          resultsInfo.textContent = "No results.";
          return;
        }
        const max = Math.min(rows.length, 200);
        const table = document.createElement("table");
        const thead = document.createElement("thead");
        const columns = Object.keys(rows[0]);
        thead.innerHTML = "<tr>" + columns.map(c => `<th>${c}</th>`).join("") + "</tr>";
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        for (let i = 0; i < max; i++) {
          const r = rows[i];
          const tr = document.createElement("tr");
          tr.innerHTML = columns.map(c => `<td>${String(r[c] ?? "")}</td>`).join("");
          tbody.appendChild(tr);
        }
        table.appendChild(tbody);
        resultsWrap.appendChild(table);
      }
    
      // -------------------------
      // Export: XLSX / CSV / JSON
      // -------------------------
      function exportToXlsx(rows) {
        if (!rows) return alert("No results to export.");
        const ws = XLSX.utils.json_to_sheet(rows);
        const wb = XLSX.utils.book_new();
        XLSX.utils.book_append_sheet(wb, ws, "DKP");
        XLSX.writeFile(wb, `dkp_output_${new Date().toISOString().replace(/[:.]/g,"-")}.xlsx`);
      }
      function exportToCsv(rows) {
        if (!rows) return alert("No results to export.");
        const ws = XLSX.utils.json_to_sheet(rows);
        const csv = XLSX.utils.sheet_to_csv(ws);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8;" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `dkp_output_${new Date().toISOString().replace(/[:.]/g,"-")}.csv`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }
      function exportToJson(rows) {
        if (!rows) return alert("No results to export.");
        const txt = JSON.stringify(rows, null, 2);
        const blob = new Blob([txt], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `dkp_output_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }
    
      // -------------------------
      // Settings export/import
      // -------------------------
      async function exportSettings() {
        const payload = {
          multipliers,
          power_ranges: powerRanges,
          vacation_list: vacationList,
          min_dkp: minDkpMap
        };
        const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `dkp_settings_${new Date().toISOString().replace(/[:.]/g,"-")}.json`;
        document.body.appendChild(a); a.click(); a.remove();
        URL.revokeObjectURL(url);
      }
    
      importSettingsBtn.addEventListener("click", () => importSettingsFile.click());
      importSettingsFile.addEventListener("change", async (ev) => {
        const file = ev.target.files && ev.target.files[0];
        if (!file) return;
        try {
          const txt = await file.text();
          const parsed = JSON.parse(txt);
          // Basic validation
          if (!parsed || typeof parsed !== "object") throw new Error("Invalid file format.");
          // accept keys (multipliers, power_ranges, vacation_list, min_dkp)
          if (parsed.multipliers) {
            multipliers = parsed.multipliers;
            await localforage.setItem(KEY_MULT, multipliers);
          }
          if (Array.isArray(parsed.power_ranges)) {
            powerRanges = parsed.power_ranges;
            await localforage.setItem(KEY_PR, powerRanges);
          }
          if (Array.isArray(parsed.vacation_list)) {
            vacationList = parsed.vacation_list;
            await localforage.setItem(KEY_VAC, vacationList);
          }
          if (parsed.min_dkp && typeof parsed.min_dkp === "object") {
            minDkpMap = parsed.min_dkp;
            await localforage.setItem(KEY_MIN, minDkpMap);
          }
          alert("Settings imported successfully.");
          // refresh UI
          populateUIFromMemory();
        } catch (err) {
          console.error(err);
          alert("Failed to import settings: " + (err.message || err));
        } finally {
          importSettingsFile.value = ""; // reset
        }
      });
    
      // -------------------------
      // Init wiring
      // -------------------------
      async function init() {
        await loadAllFromStorage();
        // --- Dark mode toggle ---
        const themeToggle = document.getElementById("theme-toggle");
        function applyTheme(isDark) {
          document.body.classList.toggle("dark", isDark);
          themeToggle.textContent = isDark ? "â˜€ï¸ Light mode" : "ðŸŒ™ Dark mode";
          localStorage.setItem("dkp_darkmode", isDark ? "1" : "0");
        }
        themeToggle.addEventListener("click", () => {
          const current = document.body.classList.contains("dark");
          applyTheme(!current);
        });
        // restore saved preference
        const savedDark = localStorage.getItem("dkp_darkmode") === "1";
        applyTheme(savedDark);
        // dark end
        populateUIFromMemory();
        renderPowerRanges();
        progressEl.value = 0;
        resultsInfo.textContent = "Ready.";
      }
    
      function populateUIFromMemory() {
        t4El.value = multipliers.t4 ?? 0;
        t5El.value = multipliers.t5 ?? 0;
        deadsEl.value = multipliers.deads ?? 0;
        vacInput.value = (vacationList || []).join(", ");
      }
    
      saveMultBtn.addEventListener("click", saveMultipliers);
      vacSaveBtn.addEventListener("click", saveVacationList);
      vacClearBtn.addEventListener("click", clearVacationList);
    
      runBtn.addEventListener("click", async () => {
        multipliers.t4 = parseFloat(t4El.value) || 0;
        multipliers.t5 = parseFloat(t5El.value) || 0;
        multipliers.deads = parseFloat(deadsEl.value) || 0;
        const mode = document.querySelector('input[name="mode"]:checked').value;
        progressEl.value = 2;
        try {
          await calculateDkp({ mode });
          await saveMinDkpMap();
        } catch (err) {
          console.error(err);
          alert("Error during calculation: " + (err.message || err));
        } finally {
          progressEl.value = 100;
        }
      });
    
      exportX.addEventListener("click", () => exportToXlsx(lastResults));
      exportC.addEventListener("click", () => exportToCsv(lastResults));
      exportJ.addEventListener("click", () => exportToJson(lastResults));
    
      exportSettingsBtn.addEventListener("click", exportSettings);
      clearMinBtn.addEventListener("click", clearAllMinDkp);
    
      // initial load
      init().catch(err => console.error("Init error", err));
    })();

  </script>
</body>
</html>
