<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<title>Fabric.js Map Editor â€” pins, arrows, labels, colors, export/import</title>
<script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
<style>
  :root { --sidebar-w: 340px; }
  body { margin: 0; font-family: system-ui, -apple-system, "Segoe UI", Roboto, Arial; height: 100vh; display: flex; }
  #canvasWrap { flex: 1; position: relative; background: #eee; display:flex; align-items:center; justify-content:center; overflow:hidden; }
  canvas { border: 1px solid #ccc; background: #fff; }
  aside { width: var(--sidebar-w); border-left: 1px solid #ddd; padding: 12px; box-sizing: border-box; display:flex; flex-direction:column; gap:10px; }
  button { padding:8px 10px; font-size:14px; cursor:pointer; }
  .controls { display: grid; gap:8px; grid-template-columns: 1fr 1fr; }
  .controls button { grid-column: span 2; }
  .row { display:flex; gap:8px; align-items:center; }
  label { font-size:13px; color:#333; }
  input[type="color"] { width:40px; height:30px; border:0; padding:0; }
  input[type="text"] { flex:1; padding:6px 8px; font-size:14px; }
  .list { border:1px solid #eee; border-radius:6px; overflow:auto; padding:6px; font-size:13px; background:#fff; flex:1; }
  table { width:100%; border-collapse: collapse; font-size:13px; }
  td, th { padding:6px; border-bottom:1px solid #f5f5f5; text-align:left; vertical-align:middle; }
  .small { font-size:12px; color:#666; }
  .flyout { position: absolute; z-index: 9999; min-width:220px; max-width: 320px; background:#fff; border:1px solid #ddd; border-radius:8px; box-shadow:0 8px 30px rgba(0,0,0,0.15); padding:10px; }
  .flyout textarea { width:100%; min-height:70px; resize:vertical; padding:6px; }
  footer .small { color:#666; text-align:center; display:block; }
  input[type="file"] { display:none; }
</style>
</head>
<body>

<div id="canvasWrap">
  <canvas id="c"></canvas>
</div>

<aside>
  <div class="controls">
    <button id="placePinBtn">Place Pin (click map)</button>
    <button id="addPinBtn">Quick Add Pin</button>
    <button id="addArrowBtn">Add Arrow</button>
    <button id="addRectBtn">Add Rectangle</button>

    <label class="small">Fill <input id="fillColor" type="color" value="#e53935"></label>
    <label class="small">Stroke <input id="strokeColor" type="color" value="#333333"></label>

    <input id="labelInput" type="text" placeholder="Label for selected" />
    <button id="applyLabelColor">Apply to Selected</button>

    <button id="exportBtn">Export JSON</button>
    <button id="importBtn">Import JSON</button>
    <input id="fileInput" type="file" accept="application/json" />

  </div>

  <div class="list" id="pinList">
    <div class="small">Pin list will appear here (pins only)</div>
  </div>

  <div>
    <small class="small">Select an object to change its color/label. For pins, click a pin to open a note editor. Export includes canvas meta (size + background) and objects.</small>
  </div>
</aside>

<script>
(function(){
  const canvasEl = document.getElementById('c');
  const wrap = document.getElementById('canvasWrap');
  const placePinBtn = document.getElementById('placePinBtn');
  const addPinBtn = document.getElementById('addPinBtn');
  const addArrowBtn = document.getElementById('addArrowBtn');
  const addRectBtn = document.getElementById('addRectBtn');
  const fillInput = document.getElementById('fillColor');
  const strokeInput = document.getElementById('strokeColor');
  const labelInput = document.getElementById('labelInput');
  const applyLabelColorBtn = document.getElementById('applyLabelColor');
  const exportBtn = document.getElementById('exportBtn');
  const importBtn = document.getElementById('importBtn');
  const fileInput = document.getElementById('fileInput');
  const pinListEl = document.getElementById('pinList');

  // initialize canvas to fill the available area (minus sidebar)
  function initCanvasSize() {
    // compute available width by measuring wrap element (it's flex; canvas will be centered)
    const w = Math.max(600, window.innerWidth - document.querySelector('aside').clientWidth - 20);
    const h = Math.max(400, window.innerHeight - 20);
    canvas.setWidth(w);
    canvas.setHeight(h);
    // also resize canvas element style so it's centered in wrapper
    canvasEl.style.width = canvas.width + 'px';
    canvasEl.style.height = canvas.height + 'px';
  }

  const canvas = new fabric.Canvas('c', { selection: true, preserveObjectStacking: true });
  initCanvasSize();
  window.addEventListener('resize', () => {
    initCanvasSize();
    // reposition flyout if open
    if (openFlyout && openTarget) positionFlyout(openFlyout, openTarget);
  });

  // Set your background image here (replace with your PNG path)
  const BG_URL = './a.png'; // <--- replace with your map file
  fabric.Image.fromURL(BG_URL, img => {
    // scale image to fit canvas while preserving aspect ratio
    const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
    img.set({ selectable: false, evented: false });
    img.scale(scale);
    // center background
    img.left = (canvas.width - img.getScaledWidth()) / 2;
    img.top  = (canvas.height - img.getScaledHeight()) / 2;
    canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
  }, { crossOrigin: 'anonymous' });

  // utility: generate stable id (keeps through export/import)
  function genId() {
    // basic uuid-like id (OK for client use)
    return 'id-' + Math.random().toString(36).slice(2, 9);
  }

  // ---------- Creation helpers ----------

  function createPinAt(left, top, labelText = '') {
    // circle + label text grouped
    const circle = new fabric.Circle({
      radius: 9,
      fill: fillInput.value || '#e53935',
      stroke: strokeInput.value || '#333',
      strokeWidth: 1,
      originX: 'center', originY: 'center',
    });
    const label = new fabric.Text(labelText || '', {
      fontSize: 12,
      originX: 'center', originY: 'center',
      top: -18, left: 0,
      visible: !!labelText,
    });
    const group = new fabric.Group([circle, label], {
      left: left, top: top,
      originX: 'center', originY: 'center',
      hasRotatingPoint: false,
      cornerStyle: 'circle'
    });
    group.setControlsVisibility({ mtr: false }); // no rotation for pins
    group.data = { type: 'pin', id: genId(), label: labelText || '', note: '' };
    // Prevent scaling of pin (keep stable size)
    group.lockScalingX = true;
    group.lockScalingY = true;

    canvas.add(group).setActiveObject(group);
    refreshPinList();
    return group;
  }

  function createArrowAt(left, top, length = 120, color = '#2b7cff', labelText = '') {
    // line goes from (0,0) to (length,0), triangle placed at (length,0)
    const line = new fabric.Line([0, 0, length, 0], {
      stroke: color, strokeWidth: 4, originX: 'left', originY: 'center', selectable: false
    });
    const head = new fabric.Triangle({
      left: length, top: 0, originX: 'center', originY: 'center', width: 14, height: 18, angle: 90, fill: color
    });
    const label = new fabric.Text(labelText || '', {
      fontSize: 12, originX: 'center', originY: 'center', left: length / 2, top: -18, visible: !!labelText
    });

    const group = new fabric.Group([line, head, label], {
      left: left, top: top,
      originX: 'left', originY: 'center',
      cornerStyle: 'rect'
    });
    // allow scaling / rotating
    group.data = { type: 'arrow', id: genId(), label: labelText || '' };
    canvas.add(group).setActiveObject(group);
    refreshPinList();
    return group;
  }

  function createRectAt(left, top, options = {}) {
    const rect = new fabric.Rect(Object.assign({
        left: 0, top: 0, width: 100, height: 70,
        fill: 'rgba(0,200,0,0.25)', stroke: '#0a8b00', strokeWidth: 2,
        originX: 'center', originY: 'center'
      }, options));
    const label = new fabric.Text(options.label || '', {
      fontSize: 12, originX: 'center', originY: 'center', top: -rect.height/2 - 10, left: 0, visible: !!options.label
    });
    const group = new fabric.Group([rect, label], {
      left: left, top: top, originX: 'center', originY: 'center'
    });
    group.data = { type: 'rect', id: genId(), label: options.label || '' };
    canvas.add(group).setActiveObject(group);
    refreshPinList();
    return group;
  }

  // ---------- Flyout for notes ----------
  let openFlyout = null;
  let openTarget = null;

  function positionFlyout(fly, targetGroup) {
    // compute bounding rect of target relative to canvas' upperCanvasEl
    const targetRect = targetGroup.getBoundingRect(true, true);
    const canvasRect = canvas.upperCanvasEl.getBoundingClientRect();
    // place flyout near top-right of the object's bounding rect (but keep inside window)
    const left = canvasRect.left + targetRect.left + targetRect.width + 8;
    const top  = canvasRect.top + targetRect.top - 8;
    fly.style.left = Math.round(left) + 'px';
    fly.style.top  = Math.round(top) + 'px';

    // nudge if offscreen (right/bottom)
    const fRect = fly.getBoundingClientRect();
    const margin = 8;
    if (fRect.right > window.innerWidth - margin) {
      fly.style.left = Math.max(margin, canvasRect.left + targetRect.left - fRect.width - 8) + 'px';
    }
    if (fRect.top < margin) {
      fly.style.top = (canvasRect.top + targetRect.top + targetRect.height + 8) + 'px';
    }
  }

  function openNoteEditorFor(group) {
    closeFlyout();

    const fly = document.createElement('div');
    fly.className = 'flyout';
    fly.innerHTML = `
      <div style="font-weight:600;margin-bottom:6px;">Edit note</div>
      <div style="margin-bottom:8px;"><input type="text" id="flyLabel" placeholder="Label (optional)" style="width:100%;padding:6px" value="${escapeHtml(group.data?.label || '')}"></div>
      <textarea id="flyNote" placeholder="Note...">${escapeHtml(group.data?.note || '')}</textarea>
      <div style="display:flex;gap:8px;margin-top:8px;justify-content:flex-end">
        <button id="flySave">Save</button>
        <button id="flyClose">Close</button>
      </div>
    `;
    // prevent clicks on flyout from interacting with canvas
    fly.addEventListener('pointerdown', e => e.stopPropagation());
    document.body.appendChild(fly);
    openFlyout = fly;
    openTarget = group;

    positionFlyout(fly, group);

    document.getElementById('flySave').addEventListener('click', () => {
      const newLabel = document.getElementById('flyLabel').value.trim();
      const newNote  = document.getElementById('flyNote').value;
      group.data.label = newLabel;
      group.data.note  = newNote;
      // update group's text child if exists
      const txt = findTextInGroup(group);
      if (txt) {
        txt.set({ text: newLabel, visible: !!newLabel });
      } else if (newLabel) {
        // create a text child above
        const t = new fabric.Text(newLabel, { fontSize: 12, originX:'center', originY:'center', top: -18, left: 0 });
        group.addWithUpdate(t);
      }
      canvas.requestRenderAll();
      refreshPinList();
      closeFlyout();
    });
    document.getElementById('flyClose').addEventListener('click', () => {
      // autosave label/note on close
      group.data.label = document.getElementById('flyLabel').value.trim();
      group.data.note  = document.getElementById('flyNote').value;
      const txt = findTextInGroup(group);
      if (txt) {
        txt.set({ text: group.data.label, visible: !!group.data.label });
      }
      canvas.requestRenderAll();
      refreshPinList();
      closeFlyout();
    });
  }

  function closeFlyout() {
    if (openFlyout) {
      openFlyout.remove();
      openFlyout = null;
      openTarget = null;
    }
  }

  function escapeHtml(s = '') {
    return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
  }

  // ---------- Helpers to inspect groups ----------
  function findShapeInGroup(group) {
    // returns first child that looks like the "shape" (Circle/Rect/Line)
    if (!group || !group._objects) return null;
    for (const o of group._objects) {
      if (o.type === 'circle' || o.type === 'rect' || o.type === 'line' || o.type === 'path') return o;
    }
    return group._objects[0] || null;
  }
  function findTextInGroup(group) {
    if (!group || !group._objects) return null;
    for (const o of group._objects) if (o.type === 'text') return o;
    return null;
  }

  // ---------- Selection UI updates ----------
  function updateControlsForSelection() {
    const obj = canvas.getActiveObject();
    if (!obj) {
      // no selection
      labelInput.value = '';
      // keep colors default
      return;
    }
    // reflect label
    labelInput.value = (obj.data?.label) || '';
    // reflect colors (pick a first colorable child)
    const main = findShapeInGroup(obj) || obj;
    // For line we look at stroke, for others prefer fill
    if (main.type === 'line') {
      strokeInput.value = main.stroke || '#000000';
      fillInput.value = main.fill || '#ffffff';
    } else {
      fillInput.value = main.fill || '#ffffff';
      strokeInput.value = main.stroke || '#000000';
    }
  }

  canvas.on('selection:created', updateControlsForSelection);
  canvas.on('selection:updated', updateControlsForSelection);
  canvas.on('selection:cleared', updateControlsForSelection);

  // When user clicks an object, if it's a pin, open note editor
  canvas.on('mouse:down', function(opt) {
    const pointer = canvas.getPointer(opt.e);
    // if we are in placePinMode and clicked on empty area -> create pin
    if (placingPin && !opt.target) {
      createPinAt(pointer.x, pointer.y, '');
      placingPin = false;
      placePinBtn.textContent = 'Place Pin (click map)';
      placePinBtn.dataset.active = 'false';
      return;
    }

    // if clicked on a group/object that's a pin, open flyout (note editor) AFTER selection occurs
    if (opt.target && opt.target.data?.type === 'pin') {
      // open editor on mouse up to avoid interfering with drag; use setTimeout for small delay
      setTimeout(() => openNoteEditorFor(opt.target), 40);
    } else {
      // clicking empty space closes flyout
      // but clicks inside flyout are stopped from propagating
      closeFlyout();
    }
  });

  // ---------- Place pin mode ----------
  let placingPin = false;
  placePinBtn.addEventListener('click', () => {
    placingPin = !placingPin;
    placePinBtn.dataset.active = placingPin ? 'true' : 'false';
    placePinBtn.textContent = placingPin ? 'Placing: click map to drop pin (Esc to cancel)' : 'Place Pin (click map)';
  });
  // cancel place mode with Escape
  window.addEventListener('keydown', (e) => {
    if (e.key === 'Escape' && placingPin) {
      placingPin = false;
      placePinBtn.textContent = 'Place Pin (click map)';
    }
  });

  // ---------- Add quick controls ----------
  addPinBtn.addEventListener('click', () => {
    // place in center
    createPinAt(canvas.width/2, canvas.height/2, '');
  });
  addArrowBtn.addEventListener('click', () => {
    createArrowAt(canvas.width/2 - 60, canvas.height/2, 120, strokeInput.value || '#2b7cff', '');
  });
  addRectBtn.addEventListener('click', () => {
    createRectAt(canvas.width/2, canvas.height/2, { label: '' });
  });

  // ---------- Update label/colors on apply ----------
  applyLabelColorBtn.addEventListener('click', () => {
    const obj = canvas.getActiveObject();
    if (!obj) return;
    const newLabel = labelInput.value.trim();
    const newFill = fillInput.value;
    const newStroke = strokeInput.value;

    // set data & visible label text if group contains text child, else add one
    obj.data = obj.data || {};
    obj.data.label = newLabel;
    // find text child
    const txt = findTextInGroup(obj);
    if (txt) {
      txt.set({ text: newLabel, visible: !!newLabel });
    } else if (newLabel) {
      const t = new fabric.Text(newLabel, { fontSize: 12, originX: 'center', originY: 'center', top: -18, left: 0 });
      obj.addWithUpdate(t);
    }

    // apply colors depending on type
    const type = obj.data?.type;
    if (type === 'pin') {
      const circle = findShapeInGroup(obj);
      if (circle) {
        circle.set({ fill: newFill, stroke: newStroke });
      }
    } else if (type === 'arrow') {
      // group: [line, head, label?]
      for (const child of obj._objects) {
        if (child.type === 'line') child.set({ stroke: newStroke });
        if (child.type === 'triangle') child.set({ fill: newStroke });
      }
    } else if (type === 'rect') {
      const rect = findShapeInGroup(obj);
      if (rect) { rect.set({ fill: newFill, stroke: newStroke }); }
    } else {
      // fallback: apply fill/stroke to main object
      const main = findShapeInGroup(obj) || obj;
      if (main.set) { main.set({ fill: newFill, stroke: newStroke }); }
    }

    canvas.requestRenderAll();
    refreshPinList();
  });

  // ---------- Pin list (only pins) ----------
  function refreshPinList() {
    const all = canvas.getObjects();
    const pins = all.filter(o => o.data?.type === 'pin');
    if (!pins.length) {
      pinListEl.innerHTML = '<div class="small">No pins yet</div>';
      return;
    }
    let html = '<table><thead><tr><th>#</th><th>XY</th><th>Label</th><th>Note</th><th>Actions</th></tr></thead><tbody>';
    pins.forEach((p, i) => {
      const left = Math.round(p.left);
      const top = Math.round(p.top);
      const lab = escapeHtml(p.data?.label || '');
      const note = escapeHtml((p.data?.note || '').slice(0, 40));
      html += `<tr data-id="${p.data.id}"><td>${i+1}</td><td>${left},${top}</td><td>${lab}</td><td>${note}</td><td>
        <button data-action="focus">Focus</button>
        <button data-action="edit">Edit Note</button>
        <button data-action="delete">Delete</button>
      </td></tr>`;
    });
    html += '</tbody></table>';
    pinListEl.innerHTML = html;
  }

  pinListEl.addEventListener('click', (ev) => {
    const btn = ev.target.closest('button');
    if (!btn) return;
    const tr = ev.target.closest('tr');
    if (!tr) return;
    const id = tr.dataset.id;
    const obj = canvas.getObjects().find(o => o.data?.id === id);
    if (!obj) return;
    const action = btn.dataset.action;
    if (action === 'focus') {
      canvas.setActiveObject(obj);
      canvas.requestRenderAll();
      // optionally animate: center view (simple)
      // center by panning viewport? For now, just ensure selected and zoom unchanged
    } else if (action === 'edit') {
      canvas.setActiveObject(obj);
      openNoteEditorFor(obj);
    } else if (action === 'delete') {
      canvas.remove(obj);
      closeFlyout();
      refreshPinList();
    }
  });

  // whenever objects change, refresh pin list (moved, scaled, added, removed)
  canvas.on('object:modified', refreshPinList);
  canvas.on('object:added', refreshPinList);
  canvas.on('object:removed', refreshPinList);
  canvas.on('object:moving', refreshPinList);

  // ---------- Export / Import ----------
  function downloadJSON(obj, filename = 'map-export.json') {
    const blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = filename;
    document.body.appendChild(a); a.click(); a.remove();
    URL.revokeObjectURL(url);
  }

  exportBtn.addEventListener('click', () => {
    const exportObj = {
      meta: {
        canvasWidth: canvas.width,
        canvasHeight: canvas.height,
        backgroundImage: canvas.backgroundImage?.src || null
      },
      json: canvas.toJSON(['data'])
    };
    downloadJSON(exportObj);
  });

  importBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', async (e) => {
    const f = e.target.files?.[0];
    if (!f) return;
    try {
      const txt = await f.text();
      const parsed = JSON.parse(txt);
      if (!parsed || !parsed.json) throw new Error('Invalid file format (expected export structure).');
      const meta = parsed.meta || {};
      // optionally set canvas size
      if (meta.canvasWidth && meta.canvasHeight) {
        canvas.setWidth(meta.canvasWidth);
        canvas.setHeight(meta.canvasHeight);
        canvasEl.style.width = canvas.width + 'px';
        canvasEl.style.height = canvas.height + 'px';
      }
      // load background if provided (and then load objects)
      function loadObjects() {
        canvas.loadFromJSON(parsed.json, () => {
          canvas.renderAll();
          // ensure each object has data.id (in case older import didn't)
          canvas.getObjects().forEach(o => { o.data = o.data || {}; if (!o.data.id) o.data.id = genId(); });
          refreshPinList();
        }, function(o, obj) {
          // reviver callback per object (optional)
        });
      }

      if (meta.backgroundImage) {
        fabric.Image.fromURL(meta.backgroundImage, img => {
          const scale = Math.min(canvas.width / img.width, canvas.height / img.height);
          img.set({ selectable: false, evented: false });
          img.scale(scale);
          img.left = (canvas.width - img.getScaledWidth()) / 2;
          img.top  = (canvas.height - img.getScaledHeight()) / 2;
          canvas.setBackgroundImage(img, canvas.renderAll.bind(canvas));
          loadObjects();
        }, { crossOrigin: 'anonymous' });
      } else {
        loadObjects();
      }
    } catch (err) {
      alert('Import error: ' + err.message);
    } finally {
      fileInput.value = '';
    }
  });

  // ---------- Final polish: clicking outside flyout closes it ----------
  document.addEventListener('pointerdown', e => {
    if (!openFlyout) return;
    if (e.target.closest('.flyout')) return; // clicked inside flyout
    // if clicked on canvas (or sidebar), close
    closeFlyout();
  });

  // initial refresh
  refreshPinList();

})();
</script>
</body>
</html>

