<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Interactive PNG Map with Pins & Flyouts</title>
<style>
  :root {
    --pin-size: 18px;
    --pin-ring: 4px;
  }

  /* Layout */
  body {
    margin: 0;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    display: grid;
    grid-template-columns: 1fr 340px;
    min-height: 100vh;
  }
  .map {
    position: relative;
    background: #f7f7f7;
    overflow: hidden;
    display: grid;
    place-items: center;
  }
  .map__img {
    max-width: 100%;
    height: auto;
    display: block;
    user-select: none;
    -webkit-user-drag: none;
    pointer-events: none; /* let the container receive clicks */
  }

  /* Pins */
  .pin {
    position: absolute;
    width: var(--pin-size);
    height: var(--pin-size);
    transform: translate(-50%, -100%); /* anchor bottom-center */
    border-radius: 50% 50% 50% 0;
    rotate: -45deg;
    border: 2px solid #111;
    background: #fff;
    box-shadow: 0 2px 6px rgba(0,0,0,.25);
    cursor: pointer;
  }
  .pin::after {
    content: "";
    position: absolute;
    inset: var(--pin-ring);
    border-radius: 50%;
    background: #e53935; /* marker head */
    rotate: 45deg;       /* neutralize parent rotation for a round head */
  }
  .pin.selected {
    box-shadow: 0 0 0 3px rgba(229,57,53,.35), 0 2px 8px rgba(0,0,0,.35);
  }
  .pin:focus-visible {
    outline: 3px solid dodgerblue;
    outline-offset: 2px;
  }

  /* Flyout (note editor) */
  .flyout {
    position: absolute;
    transform: translate(12px, -100%);
    background: #fff;
    border: 1px solid #d9d9d9;
    border-radius: 8px;
    padding: 8px;
    min-width: 200px;
    max-width: min(260px, 40vw);
    box-shadow: 0 6px 18px rgba(0,0,0,.18);
    z-index: 10;
  }
  .flyout header {
    font-size: 13px;
    color: #555;
    margin-bottom: 6px;
  }
  .flyout textarea, .flyout input[type="text"] {
    max-width: 100%;
    font-size: 14px;
    border: 1px solid #ccc;
    border-radius: 6px;
    padding: 6px 8px;
    resize: vertical;
  }
  .flyout textarea { min-height: 60px; }
  .flyout .row {
    display: flex; gap: 8px; margin-top: 8px; align-items: center;
  }
  .flyout button {
    padding: 6px 10px;
    border: 1px solid #ccc;
    background: #fafafa;
    border-radius: 6px;
    cursor: pointer;
    font-size: 13px;
  }
  .flyout button:hover { background: #f0f0f0; }

  /* Sidebar */
  aside {
    border-left: 1px solid #e5e5e5;
    padding: 14px;
    display: grid;
    grid-template-rows: auto 1fr auto;
    gap: 12px;
    background: #fff;
  }
  .controls {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
  }
  .controls button,
  .controls label {
    font-size: 14px;
  }
  .controls button {
    padding: 8px 12px;
    border: 1px solid #ccc;
    background: #fafafa;
    border-radius: 6px;
    cursor: pointer;
  }
  .controls button:hover { background: #f0f0f0; }
  .controls label {
    display: inline-flex; gap: 6px; align-items: center;
    padding: 6px 8px; border: 1px solid #eee; border-radius: 6px;
    background: #fcfcfc;
  }

  .list {
    overflow: auto;
    border: 1px solid #eee;
    border-radius: 8px;
    height: 40vw;
  }
  .list table {
    width: 100%;
    border-collapse: collapse;
    font-size: 14px;
  }
  .list th, .list td {
        padding: 8px;
        border-bottom: 1px solid #f5f5f5;
        text-align: left;
        white-space: nowrap;
  }
  /* Hide Action column and buttons from pin list */
  .list th:last-child {display: none;}
  .list td.actions { display: none;}
  .list tr:hover { background: #fafafa; }
  .empty {
    padding: 12px;
    color: #666;
    text-align: center;
  }
  footer small { color: #666; }

  @media (max-width: 900px) {
    body { grid-template-columns: 1fr; }
    aside { order: -1; border-left: none; border-bottom: 1px solid #e5e5e5; }
  }
</style>
</head>
<body>

  <!-- MAP -->
  <div class="map" id="map" aria-label="Interactive map" role="application">
    <img class="map__img" id="mapImg" src="a.png" alt="Background map" />
  </div>

  <!-- SIDEBAR -->
  <aside>
    <div class="controls">
      <button id="toggleAdd">Add pins: ON</button>
      <button id="clearSelected">Clear selected</button>
      <button id="deleteSelected">Delete selected</button>
      <button id="exportJson">Export JSON</button>
      <button id="importJson">Import JSON</button>
      <input id="fileInput" type="file" accept="application/json" hidden />
      <label title="Prevent adding/removing/editing">
        <input type="checkbox" id="lockPins" />
        Lock pins
      </label>
    </div>

    <div class="list" id="pinList">
      <div class="empty">No pins yet. Click on the map to add one.</div>
    </div>

    <footer>
      <small>
        Tips: Click the map to drop a pin. Click a pin to open its note.  
        Hold <kbd>Shift</kbd> while adding to set a label. Use <em>Lock pins</em> for read-only viewing.
      </small>
    </footer>
  </aside>

<script>
(function(){
  const map = document.getElementById('map');
  const img = document.getElementById('mapImg');
  const toggleAddBtn = document.getElementById('toggleAdd');
  const clearSelectedBtn = document.getElementById('clearSelected');
  const deleteSelectedBtn = document.getElementById('deleteSelected');
  const exportBtn = document.getElementById('exportJson');
  const importBtn = document.getElementById('importJson');
  const fileInput = document.getElementById('fileInput');
  const lockPinsCheckbox = document.getElementById('lockPins');
  const pinList = document.getElementById('pinList');

  let addMode = true;
  let pins = []; // {id, xPct, yPct, label, note, selected}
  let openFlyout = null;
  let openPin = null;

  function clamp(n, min, max) { return Math.max(min, Math.min(n, max)); }

  function pctFromEvent(e) {
    const r = map.getBoundingClientRect();
    const x = ((e.clientX - r.left) / r.width) * 100;
    const y = ((e.clientY - r.top) / r.height) * 100;
    return { xPct: clamp(x, 0, 100), yPct: clamp(y, 0, 100) };
  }

  function renderPin(p) {
    let el = document.querySelector(`.pin[data-id="${p.id}"]`);
    if (!el) {
      el = document.createElement('button');
      el.className = 'pin';
      el.type = 'button';
      el.setAttribute('data-id', p.id);
      el.setAttribute('aria-label', p.label ? `Pin: ${p.label}` : 'Pin');
      el.title = p.label || 'Pin';
      el.addEventListener('click', (ev) => {
        ev.stopPropagation(); // don't trigger map click
        if (lockPinsCheckbox.checked) return; // read-only
        p.selected = !p.selected;
        el.classList.toggle('selected', p.selected);
        showFlyout(el, p);
        updateList();
      });
      el.addEventListener('keydown', (ev) => {
        if (ev.key === ' ' || ev.key === 'Enter') {
          ev.preventDefault();
          el.click();
        }
      });
      map.appendChild(el);
    }
    el.style.left = `${p.xPct}%`;
    el.style.top  = `${p.yPct}%`;
    el.classList.toggle('selected', !!p.selected);
  }

  function renderAllPins() { pins.forEach(renderPin); }

  function addPinAt(xPct, yPct, label = '') {
    const p = {
      id: crypto.randomUUID(),
      xPct, yPct,
      label: label || '',
      note: '',
      selected: false
    };
    pins.push(p);
    renderPin(p);
    updateList();
    return p;
  }

  function removeSelectedPins() {
    const selectedIds = new Set(pins.filter(p => p.selected).map(p => p.id));
    pins = pins.filter(p => !selectedIds.has(p.id));
    // Remove DOM nodes
    [...document.querySelectorAll('.pin')].forEach(el => {
      if (selectedIds.has(el.dataset.id)) el.remove();
    });
    if (openPin && selectedIds.has(openPin.id)) closeFlyout();
    updateList();
  }

  function clearSelected() {
    pins.forEach(p => p.selected = false);
    document.querySelectorAll('.pin.selected').forEach(el => el.classList.remove('selected'));
    updateList();
  }

  function updateList() {
    if (!pins.length) {
      pinList.innerHTML = `<div class="empty">No pins yet. Click on the map to add one.</div>`;
      return;
    }
    const rows = pins.map((p, idx) => {
      const cls = p.selected ? 'style="background:#fff7f7"' : '';
      const label = escapeHtml(p.label || '');
      const noteShort = escapeHtml((p.note || '').slice(0, 50));
      return `
        <tr ${cls} data-id="${p.id}">
          <td>#${idx+1}</td>
          <td>${p.xPct.toFixed(2)}%</td>
          <td>${p.yPct.toFixed(2)}%</td>
          <td>${label}</td>
          <td title="${noteShort}">${noteShort}</td>
          <td class="actions">
            <button data-action="focus">Focus</button>
            <button data-action="toggle">Toggle</button>
            <button data-action="editlabel">Label</button>
            <button data-action="editnote">Note</button>
            <button data-action="delete">Delete</button>
          </td>
        </tr>`;
    }).join('');
    pinList.innerHTML = `
      <table>
        <thead>
          <tr>
            <th>Pin</th><th>X</th><th>Y</th><th>Label</th><th>Note</th><th>Actions</th>
          </tr>
        </thead>
        <tbody>${rows}</tbody>
      </table>`;
  }

pinList.addEventListener('click', (e) => {
  const tr = e.target.closest('tr');
  if (!tr) return;

  const id = tr.dataset.id;
  const p = pins.find(p => p.id === id);
  if (!p) return;

  const el = document.querySelector(`.pin[data-id="${id}"]`);

  // If clicked an action button â†’ existing logic
  const btn = e.target.closest('button');
  if (btn) {
    const action = btn.dataset.action;
    // ... keep your existing action handling code here ...
    return;
  }

  // Otherwise, clicked the row itself â†’ open flyout
    if (el && !lockPinsCheckbox.checked) {
    p.selected = true;
    el.classList.add('selected');
    showFlyout(el, p);
    }

});


  function exportJSON() {
    const data = JSON.stringify(pins, null, 2);
    const blob = new Blob([data], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = Object.assign(document.createElement('a'), {
      href: url,
      download: 'pins.json'
    });
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  async function importJSONFile(file) {
    try {
      const text = await file.text();
      const incoming = JSON.parse(text);
      if (!Array.isArray(incoming)) throw new Error('Invalid format: expected an array of pins');
      // Decide: append or replace
      let append = true;
      if (pins.length) {
        append = confirm('Append imported pins to existing ones?\nClick OK to Append, Cancel to Replace.');
      }
      if (!append) removeAllPins();
      for (const item of incoming) {
        // validate & normalize
        const x = Number(item.xPct), y = Number(item.yPct);
        if (isFinite(x) && isFinite(y)) {
          const p = {
            id: crypto.randomUUID(),
            xPct: clamp(x, 0, 100),
            yPct: clamp(y, 0, 100),
            label: typeof item.label === 'string' ? item.label : '',
            note:  typeof item.note  === 'string' ? item.note  : '',
            selected: !!item.selected
          };
          pins.push(p);
          renderPin(p);
        }
      }
      updateList();
    } catch (err) {
      alert('Failed to import JSON: ' + err.message);
    }
  }

  function removeAllPins() {
    pins = [];
    document.querySelectorAll('.pin').forEach(el => el.remove());
    closeFlyout();
    updateList();
  }

  function escapeHtml(str) {
    return String(str).replace(/[&<>"']/g, c => ({
      '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'
    }[c]));
  }

  /* ---------- Flyout logic ---------- */

  function showFlyout(pinEl, pinObj, focusNote = false) {
    closeFlyout(); // ensure only one

    const fly = document.createElement('div');
    fly.className = 'flyout';
    fly.innerHTML = `
      <header>${pinObj.label ? escapeHtml(pinObj.label) : 'Note'}</header>
      <input type="text" class="labelInput" placeholder="Label (optional)" value="${escapeHtml(pinObj.label || '')}">
      <div class="row"><textarea class="noteArea" placeholder="Write a note...">${escapeHtml(pinObj.note || '')}</textarea></div>
      <div class="row">
        <button class="saveBtn">Save</button>
        <button class="closeBtn" type="button">Close</button>
      </div>
    `;

    // Prevent clicks inside the flyout from bubbling to the map (bug fix)
    fly.addEventListener('click', ev => ev.stopPropagation());
    fly.addEventListener('mousedown', ev => ev.stopPropagation());
    fly.addEventListener('touchstart', ev => ev.stopPropagation());

    map.appendChild(fly);

    positionFlyoutNearPin(fly, pinEl);

    const saveBtn  = fly.querySelector('.saveBtn');
    const closeBtn = fly.querySelector('.closeBtn');
    const noteEl   = fly.querySelector('.noteArea');
    const labelEl  = fly.querySelector('.labelInput');

    saveBtn.addEventListener('click', () => {
      if (lockPinsCheckbox.checked) return;
      pinObj.note  = noteEl.value;
      pinObj.label = labelEl.value.trim();
      const el = document.querySelector(`.pin[data-id="${pinObj.id}"]`);
      if (el) {
        el.title = pinObj.label || 'Pin';
        el.setAttribute('aria-label', pinObj.label ? `Pin: ${pinObj.label}` : 'Pin');
      }
      updateList();
      closeFlyout();
    });
    closeBtn.addEventListener('click', () => {
      // autosave as you close
      if (!lockPinsCheckbox.checked) {
        pinObj.note  = noteEl.value;
        pinObj.label = labelEl.value.trim();
        const el = document.querySelector(`.pin[data-id="${pinObj.id}"]`);
        if (el) {
          el.title = pinObj.label || 'Pin';
          el.setAttribute('aria-label', pinObj.label ? `Pin: ${pinObj.label}` : 'Pin');
        }
        updateList();
      }
      closeFlyout();
    });

    openFlyout = fly;
    openPin = pinObj;

    // Optionally focus note field
    if (focusNote) noteEl.focus();
  }

  function positionFlyoutNearPin(fly, pinEl) {
    const rect = pinEl.getBoundingClientRect();
    const mapRect = map.getBoundingClientRect();
    // Default position: to the right & above the pin
    let left = rect.left - mapRect.left + 12;
    let top  = rect.top  - mapRect.top - 12;

    // Keep within map bounds
    const margin = 8;
    fly.style.left = `${left}px`;
    fly.style.top  = `${top}px`;
    // After layout, nudge if overflowing
    requestAnimationFrame(() => {
      const f = fly.getBoundingClientRect();
      // Right overflow
      if (f.right > mapRect.right - margin) {
        left -= (f.right - (mapRect.right - margin));
      }
      // Left overflow
      if (left < margin) left = margin;
      // Top overflow
      if (f.top < mapRect.top + margin) {
        top = (rect.bottom - mapRect.top) + 12; // place below the pin
      }
      // Bottom overflow
      if (top + f.height > mapRect.height - margin) {
        top = mapRect.height - f.height - margin;
      }
      fly.style.left = `${left}px`;
      fly.style.top  = `${top}px`;
    });
  }

  function closeFlyout() {
    if (openFlyout) {
      openFlyout.remove();
      openFlyout = null;
      openPin = null;
    }
  }

  /* ---------- Event wiring ---------- */

  // Click on map: add pin (only if not clicking pin/flyout) OR close flyout
  map.addEventListener('click', (e) => {
    // If the click originated on a pin or within a flyout, ignore here
    if (e.target.closest('.pin') || e.target.closest('.flyout')) return;

    if (addMode && !lockPinsCheckbox.checked) {
      const { xPct, yPct } = pctFromEvent(e);
      const label = e.shiftKey ? (prompt('Label for this pin? (optional)') || '') : '';
      addPinAt(xPct, yPct, label);
    } else {
      // Clicking empty space closes any open flyout
      closeFlyout();
    }
  });

  // Also close flyout when clicking outside the map/flyout (e.g., sidebar)
document.addEventListener('click', (e) => {
  if (
    e.target.closest('#map') ||
    e.target.closest('.flyout') ||
    e.target.closest('.pin') ||
    e.target.closest('#pinList')   // ðŸ‘ˆ new exception
  ) return;

  closeFlyout();
});


  // Keep pins and any open flyout well positioned on resize
  window.addEventListener('resize', () => {
    renderAllPins();
    if (openFlyout && openPin) {
      const el = document.querySelector(`.pin[data-id="${openPin.id}"]`);
      if (el) positionFlyoutNearPin(openFlyout, el);
    }
  });

  toggleAddBtn.addEventListener('click', () => {
    addMode = !addMode;
    toggleAddBtn.textContent = `Add pins: ${addMode ? 'ON' : 'OFF'}`;
  });
  clearSelectedBtn.addEventListener('click', clearSelected);
  deleteSelectedBtn.addEventListener('click', removeSelectedPins);
  exportBtn.addEventListener('click', exportJSON);
  importBtn.addEventListener('click', () => fileInput.click());
  fileInput.addEventListener('change', (e) => {
    const file = e.target.files?.[0];
    if (file) importJSONFile(file).finally(() => (fileInput.value = ''));
  });

  // Optional: quick demo pins
  // addPinAt(25, 40, 'Sample A');
  // addPinAt(62, 73, 'Sample B');

  /* ---------- Dragging logic ---------- */
  let dragging = null;

  map.addEventListener("mousedown", (e) => {
    const el = e.target.closest(".pin");
    if (!el || lockPinsCheckbox.checked) return;

    e.preventDefault();
    const id = el.dataset.id;
    const p = pins.find((p) => p.id === id);
    if (!p) return;

    dragging = { el, p };
  });

  window.addEventListener("mousemove", (e) => {
    if (!dragging) return;
    e.preventDefault();

    const { xPct, yPct } = pctFromEvent(e);
    dragging.p.xPct = xPct;
    dragging.p.yPct = yPct;

    dragging.el.style.left = `${xPct}%`;
    dragging.el.style.top = `${yPct}%`;
  });

  window.addEventListener("mouseup", () => {
    if (dragging) {
      updateList(); // keep sidebar in sync
      dragging = null;
    }
  });

  // --- Touch support ---
  map.addEventListener("touchstart", (e) => {
    const el = e.target.closest(".pin");
    if (!el || lockPinsCheckbox.checked) return;

    const touch = e.touches[0];
    const id = el.dataset.id;
    const p = pins.find((p) => p.id === id);
    if (!p) return;

    dragging = { el, p, touchId: touch.identifier };
  });

  window.addEventListener("touchmove", (e) => {
    if (!dragging) return;

    const touch = [...e.touches].find((t) => t.identifier === dragging.touchId);
    if (!touch) return;

    const { xPct, yPct } = pctFromEvent(touch);
    dragging.p.xPct = xPct;
    dragging.p.yPct = yPct;

    dragging.el.style.left = `${xPct}%`;
    dragging.el.style.top = `${yPct}%`;
  });

  window.addEventListener("touchend", (e) => {
    if (!dragging) return;

    // end if the tracked finger is lifted
    const stillTouching = [...e.touches].some(
      (t) => t.identifier === dragging.touchId
    );
    if (!stillTouching) {
      updateList();
      dragging = null;
    }
  });

async function loadPinsFromFile() {
  try {
    const resp = await fetch("pins.json", { cache: "no-store" });
    if (!resp.ok) throw new Error("Failed to load pins.json");
    const data = await resp.json();
    if (!Array.isArray(data)) throw new Error("pins.json is not an array");

    removeAllPins(); // clear current pins
    for (const item of data) {
      const x = Number(item.xPct), y = Number(item.yPct);
      if (isFinite(x) && isFinite(y)) {
        const p = {
          id: crypto.randomUUID(),
          xPct: clamp(x, 0, 100),
          yPct: clamp(y, 0, 100),
          label: typeof item.label === "string" ? item.label : "",
          note:  typeof item.note  === "string" ? item.note  : "",
          selected: false
        };
        pins.push(p);
        renderPin(p);
      }
    }
    updateList();
  } catch (err) {
    console.error("Error loading pins.json:", err);
  }
}

// Call it on startup
loadPinsFromFile();

})();
</script>
</body>
</html>
